---
phase: 02-location-discovery
plan: 01
type: execute
---

<objective>
Create location detection service with types, mock data, and browser geolocation integration.

Purpose: Establish the location-first discovery foundation that all deal browsing depends on.
Output: Location types, mock city/area data, useLocation hook, location context provider.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@CLAUDE.md

**Depends on:** Phase 1 complete (Next.js 16, design system, mock data layer patterns)

**Location-first discovery (from PROJECT.md):**
- Medspa services are local; location is primary filter
- Auto-detect + manual override
- Core to the browse → filter → compare → claim flow

**Mock data requirements:**
- Must align with Supabase schema structure
- Cities: major metros (LA, NYC, Miami, etc.)
- Areas: neighborhoods/districts within cities
- Support "near me" concept with coordinates

**From Phase 1 patterns:**
- Design tokens in src/lib/design-tokens.ts
- Components in src/components/ui/
- Types in src/types/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create location types and mock data</name>
  <files>src/types/location.ts, src/lib/data/locations.ts</files>
  <action>
1. Create src/types/location.ts with types matching Supabase schema expectations:
   ```typescript
   export interface City {
     id: string
     name: string
     state: string
     stateCode: string
     country: string
     latitude: number
     longitude: number
     timezone: string
   }

   export interface Area {
     id: string
     cityId: string
     name: string
     slug: string
     latitude: number
     longitude: number
     radius: number // km
   }

   export interface UserLocation {
     type: 'detected' | 'selected' | 'default'
     city: City | null
     area: Area | null
     coordinates: {
       latitude: number
       longitude: number
     } | null
     accuracy: number | null // meters
   }

   export interface LocationState {
     current: UserLocation
     isLoading: boolean
     error: string | null
     hasPermission: boolean | null
   }
   ```

2. Create src/lib/data/locations.ts with mock data for 6-8 major medspa markets:
   ```typescript
   import type { City, Area } from '@/types/location'

   export const cities: City[] = [
     {
       id: 'la',
       name: 'Los Angeles',
       state: 'California',
       stateCode: 'CA',
       country: 'USA',
       latitude: 34.0522,
       longitude: -118.2437,
       timezone: 'America/Los_Angeles',
     },
     {
       id: 'nyc',
       name: 'New York',
       state: 'New York',
       stateCode: 'NY',
       country: 'USA',
       latitude: 40.7128,
       longitude: -74.0060,
       timezone: 'America/New_York',
     },
     {
       id: 'miami',
       name: 'Miami',
       state: 'Florida',
       stateCode: 'FL',
       country: 'USA',
       latitude: 25.7617,
       longitude: -80.1918,
       timezone: 'America/New_York',
     },
     {
       id: 'dallas',
       name: 'Dallas',
       state: 'Texas',
       stateCode: 'TX',
       country: 'USA',
       latitude: 32.7767,
       longitude: -96.7970,
       timezone: 'America/Chicago',
     },
     {
       id: 'scottsdale',
       name: 'Scottsdale',
       state: 'Arizona',
       stateCode: 'AZ',
       country: 'USA',
       latitude: 33.4942,
       longitude: -111.9261,
       timezone: 'America/Phoenix',
     },
     {
       id: 'denver',
       name: 'Denver',
       state: 'Colorado',
       stateCode: 'CO',
       country: 'USA',
       latitude: 39.7392,
       longitude: -104.9903,
       timezone: 'America/Denver',
     },
   ]

   export const areas: Area[] = [
     // Los Angeles
     { id: 'la-beverly-hills', cityId: 'la', name: 'Beverly Hills', slug: 'beverly-hills', latitude: 34.0736, longitude: -118.4004, radius: 5 },
     { id: 'la-santa-monica', cityId: 'la', name: 'Santa Monica', slug: 'santa-monica', latitude: 34.0195, longitude: -118.4912, radius: 5 },
     { id: 'la-west-hollywood', cityId: 'la', name: 'West Hollywood', slug: 'west-hollywood', latitude: 34.0900, longitude: -118.3617, radius: 3 },
     // NYC
     { id: 'nyc-manhattan', cityId: 'nyc', name: 'Manhattan', slug: 'manhattan', latitude: 40.7831, longitude: -73.9712, radius: 8 },
     { id: 'nyc-brooklyn', cityId: 'nyc', name: 'Brooklyn', slug: 'brooklyn', latitude: 40.6782, longitude: -73.9442, radius: 10 },
     { id: 'nyc-upper-east-side', cityId: 'nyc', name: 'Upper East Side', slug: 'upper-east-side', latitude: 40.7736, longitude: -73.9566, radius: 3 },
     // Miami
     { id: 'miami-south-beach', cityId: 'miami', name: 'South Beach', slug: 'south-beach', latitude: 25.7826, longitude: -80.1341, radius: 4 },
     { id: 'miami-brickell', cityId: 'miami', name: 'Brickell', slug: 'brickell', latitude: 25.7617, longitude: -80.1918, radius: 3 },
     { id: 'miami-coral-gables', cityId: 'miami', name: 'Coral Gables', slug: 'coral-gables', latitude: 25.7215, longitude: -80.2684, radius: 5 },
     // Dallas
     { id: 'dallas-uptown', cityId: 'dallas', name: 'Uptown', slug: 'uptown', latitude: 32.8029, longitude: -96.8003, radius: 4 },
     { id: 'dallas-highland-park', cityId: 'dallas', name: 'Highland Park', slug: 'highland-park', latitude: 32.8332, longitude: -96.7919, radius: 3 },
     // Scottsdale
     { id: 'scottsdale-old-town', cityId: 'scottsdale', name: 'Old Town', slug: 'old-town', latitude: 33.4942, longitude: -111.9261, radius: 4 },
     { id: 'scottsdale-north', cityId: 'scottsdale', name: 'North Scottsdale', slug: 'north-scottsdale', latitude: 33.6000, longitude: -111.8900, radius: 8 },
     // Denver
     { id: 'denver-cherry-creek', cityId: 'denver', name: 'Cherry Creek', slug: 'cherry-creek', latitude: 39.7170, longitude: -104.9531, radius: 4 },
     { id: 'denver-lodo', cityId: 'denver', name: 'LoDo', slug: 'lodo', latitude: 39.7550, longitude: -105.0005, radius: 3 },
   ]

   // Helper functions
   export function getCityById(id: string): City | undefined {
     return cities.find(c => c.id === id)
   }

   export function getAreasByCityId(cityId: string): Area[] {
     return areas.filter(a => a.cityId === cityId)
   }

   export function getAreaById(id: string): Area | undefined {
     return areas.find(a => a.id === id)
   }

   export function findNearestCity(lat: number, lng: number): City {
     // Haversine distance calculation
     const toRad = (deg: number) => deg * Math.PI / 180

     let nearest = cities[0]
     let minDistance = Infinity

     for (const city of cities) {
       const dLat = toRad(city.latitude - lat)
       const dLng = toRad(city.longitude - lng)
       const a = Math.sin(dLat/2) ** 2 +
                 Math.cos(toRad(lat)) * Math.cos(toRad(city.latitude)) *
                 Math.sin(dLng/2) ** 2
       const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))
       const distance = 6371 * c // km

       if (distance < minDistance) {
         minDistance = distance
         nearest = city
       }
     }

     return nearest
   }

   // Default location (Los Angeles)
   export const DEFAULT_CITY = cities[0]
   export const DEFAULT_LOCATION: UserLocation = {
     type: 'default',
     city: DEFAULT_CITY,
     area: null,
     coordinates: null,
     accuracy: null,
   }
   ```
  </action>
  <verify>TypeScript compiles with `npm run build`, types are exported correctly</verify>
  <done>Location types defined, 6 cities with 15+ areas, helper functions for finding nearest city</done>
</task>

<task type="auto">
  <name>Task 2: Create useGeolocation hook and location context</name>
  <files>src/lib/hooks/useGeolocation.ts, src/lib/context/locationContext.tsx</files>
  <action>
1. Create src/lib/hooks/useGeolocation.ts:
   ```typescript
   'use client'

   import { useState, useCallback } from 'react'

   interface GeolocationState {
     coordinates: { latitude: number; longitude: number } | null
     accuracy: number | null
     isLoading: boolean
     error: string | null
     timestamp: number | null
   }

   interface GeolocationOptions {
     enableHighAccuracy?: boolean
     timeout?: number
     maximumAge?: number
   }

   const defaultOptions: GeolocationOptions = {
     enableHighAccuracy: false,
     timeout: 10000,
     maximumAge: 300000, // 5 minutes
   }

   export function useGeolocation(options: GeolocationOptions = {}) {
     const [state, setState] = useState<GeolocationState>({
       coordinates: null,
       accuracy: null,
       isLoading: false,
       error: null,
       timestamp: null,
     })

     const getCurrentPosition = useCallback((): Promise<GeolocationPosition> => {
       return new Promise((resolve, reject) => {
         if (!navigator.geolocation) {
           reject(new Error('Geolocation is not supported by your browser'))
           return
         }

         const opts = { ...defaultOptions, ...options }

         navigator.geolocation.getCurrentPosition(
           resolve,
           (error) => {
             switch (error.code) {
               case error.PERMISSION_DENIED:
                 reject(new Error('Location permission denied'))
                 break
               case error.POSITION_UNAVAILABLE:
                 reject(new Error('Location information unavailable'))
                 break
               case error.TIMEOUT:
                 reject(new Error('Location request timed out'))
                 break
               default:
                 reject(new Error('An unknown error occurred'))
             }
           },
           {
             enableHighAccuracy: opts.enableHighAccuracy,
             timeout: opts.timeout,
             maximumAge: opts.maximumAge,
           }
         )
       })
     }, [options])

     const requestLocation = useCallback(async () => {
       setState(prev => ({ ...prev, isLoading: true, error: null }))

       try {
         const position = await getCurrentPosition()
         setState({
           coordinates: {
             latitude: position.coords.latitude,
             longitude: position.coords.longitude,
           },
           accuracy: position.coords.accuracy,
           isLoading: false,
           error: null,
           timestamp: position.timestamp,
         })
         return position
       } catch (error) {
         const errorMessage = error instanceof Error ? error.message : 'Failed to get location'
         setState(prev => ({
           ...prev,
           isLoading: false,
           error: errorMessage,
         }))
         throw error
       }
     }, [getCurrentPosition])

     const clearLocation = useCallback(() => {
       setState({
         coordinates: null,
         accuracy: null,
         isLoading: false,
         error: null,
         timestamp: null,
       })
     }, [])

     return {
       ...state,
       requestLocation,
       clearLocation,
       isSupported: typeof navigator !== 'undefined' && 'geolocation' in navigator,
     }
   }
   ```

2. Create src/lib/context/locationContext.tsx:
   ```typescript
   'use client'

   import { createContext, useContext, useState, useCallback, useEffect, type ReactNode } from 'react'
   import type { UserLocation, City, Area, LocationState } from '@/types/location'
   import { cities, areas, findNearestCity, DEFAULT_LOCATION, getAreasByCityId } from '@/lib/data/locations'
   import { useGeolocation } from '@/lib/hooks/useGeolocation'

   interface LocationContextValue extends LocationState {
     cities: City[]
     getAreasForCity: (cityId: string) => Area[]
     detectLocation: () => Promise<void>
     selectCity: (city: City) => void
     selectArea: (area: Area | null) => void
     clearSelection: () => void
   }

   const LocationContext = createContext<LocationContextValue | null>(null)

   const STORAGE_KEY = 'costfinders_location'

   export function LocationProvider({ children }: { children: ReactNode }) {
     const [state, setState] = useState<LocationState>({
       current: DEFAULT_LOCATION,
       isLoading: false,
       error: null,
       hasPermission: null,
     })

     const { requestLocation, isSupported } = useGeolocation()

     // Load saved location on mount
     useEffect(() => {
       try {
         const saved = localStorage.getItem(STORAGE_KEY)
         if (saved) {
           const parsed = JSON.parse(saved) as UserLocation
           // Validate saved data has required fields
           if (parsed.city && parsed.type) {
             setState(prev => ({ ...prev, current: parsed }))
           }
         }
       } catch {
         // Ignore parse errors, use default
       }
     }, [])

     // Save location changes
     useEffect(() => {
       if (state.current.type !== 'default') {
         try {
           localStorage.setItem(STORAGE_KEY, JSON.stringify(state.current))
         } catch {
           // Ignore storage errors
         }
       }
     }, [state.current])

     const detectLocation = useCallback(async () => {
       if (!isSupported) {
         setState(prev => ({
           ...prev,
           error: 'Geolocation not supported',
           hasPermission: false,
         }))
         return
       }

       setState(prev => ({ ...prev, isLoading: true, error: null }))

       try {
         const position = await requestLocation()
         const { latitude, longitude } = position.coords
         const nearestCity = findNearestCity(latitude, longitude)

         setState(prev => ({
           ...prev,
           current: {
             type: 'detected',
             city: nearestCity,
             area: null,
             coordinates: { latitude, longitude },
             accuracy: position.coords.accuracy,
           },
           isLoading: false,
           error: null,
           hasPermission: true,
         }))
       } catch (error) {
         const message = error instanceof Error ? error.message : 'Failed to detect location'
         setState(prev => ({
           ...prev,
           isLoading: false,
           error: message,
           hasPermission: message.includes('denied') ? false : prev.hasPermission,
         }))
       }
     }, [isSupported, requestLocation])

     const selectCity = useCallback((city: City) => {
       setState(prev => ({
         ...prev,
         current: {
           type: 'selected',
           city,
           area: null,
           coordinates: { latitude: city.latitude, longitude: city.longitude },
           accuracy: null,
         },
         error: null,
       }))
     }, [])

     const selectArea = useCallback((area: Area | null) => {
       setState(prev => ({
         ...prev,
         current: {
           ...prev.current,
           area,
           coordinates: area
             ? { latitude: area.latitude, longitude: area.longitude }
             : prev.current.city
               ? { latitude: prev.current.city.latitude, longitude: prev.current.city.longitude }
               : null,
         },
       }))
     }, [])

     const clearSelection = useCallback(() => {
       setState(prev => ({
         ...prev,
         current: DEFAULT_LOCATION,
       }))
       try {
         localStorage.removeItem(STORAGE_KEY)
       } catch {
         // Ignore
       }
     }, [])

     const getAreasForCity = useCallback((cityId: string) => {
       return getAreasByCityId(cityId)
     }, [])

     return (
       <LocationContext.Provider
         value={{
           ...state,
           cities,
           getAreasForCity,
           detectLocation,
           selectCity,
           selectArea,
           clearSelection,
         }}
       >
         {children}
       </LocationContext.Provider>
     )
   }

   export function useLocation() {
     const context = useContext(LocationContext)
     if (!context) {
       throw new Error('useLocation must be used within a LocationProvider')
     }
     return context
   }
   ```
  </action>
  <verify>TypeScript compiles, hooks are importable, no React errors in console</verify>
  <done>useGeolocation hook handles browser API, LocationContext provides app-wide location state with persistence</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Location types properly exported from src/types/location.ts
- [ ] Mock cities and areas data loads correctly
- [ ] findNearestCity returns correct city for given coordinates
- [ ] useGeolocation hook handles all error states
- [ ] LocationContext properly initializes with default location
- [ ] Location persists to localStorage on selection
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- 6 cities with 15+ areas in mock data
- useGeolocation hook fully handles browser Geolocation API
- LocationContext provides: current location, detect, select city/area, clear
- Location persists across page refreshes via localStorage
</success_criteria>

<output>
After completion, create `.planning/phases/02-location-discovery/02-01-SUMMARY.md`
</output>
