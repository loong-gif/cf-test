---
phase: 04-consumer-auth
plan: 01
type: execute
---

<objective>
Create AuthContext for mock authentication state and sign-up form component.

Purpose: Establish auth state management pattern and build the primary account creation UI.
Output: AuthContext provider, AuthProvider wrapper, SignUpForm component with validation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/03-deal-browsing/03-04-SUMMARY.md

# Existing patterns to follow:
@src/lib/context/locationContext.tsx - Context pattern to match
@src/types/consumer.ts - Consumer and VerificationStatus types
@src/lib/mock-data/consumers.ts - Mock consumer data
@src/components/ui/input.tsx - Input component
@src/components/ui/button.tsx - Button component
@src/components/ui/modal.tsx - Modal pattern
@src/app/layout.tsx - Provider placement

**Tech stack available:** Next.js 16, React Context, TypeScript, Tailwind CSS v4
**Established patterns:** Context + Provider pattern (locationContext), glassmorphic UI components
**Constraining decisions:**
- Phase 03-04: ClaimCTA ready to receive real onSignUp/onSignIn handlers
- Mock auth only (no real backend)
- Consumer type already defined with VerificationStatus
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthContext and AuthProvider</name>
  <files>src/lib/context/authContext.tsx</files>
  <action>
Create AuthContext following locationContext.tsx pattern:

1. AuthState interface:
   - user: Consumer | null
   - isAuthenticated: boolean
   - isLoading: boolean
   - error: string | null

2. AuthContextValue interface:
   - state: AuthState
   - signUp: (email: string, password: string, firstName?: string, lastName?: string) => Promise<void>
   - signIn: (email: string, password: string) => Promise<void>
   - signOut: () => void
   - updateVerificationStatus: (status: VerificationStatus) => void

3. AuthProvider component:
   - Use useState for auth state
   - localStorage persistence with key 'costfinders_auth' (store user ID only)
   - signUp: Create mock user with 'unverified' status, store in state
   - signIn: Find user in mock consumers by email, validate exists, store in state
   - signOut: Clear state and localStorage
   - updateVerificationStatus: Update user's verification status in state

4. useAuth hook with context validation

Note: This is mock auth - no real password validation. Just check email format and store user. Password is accepted but not verified.
  </action>
  <verify>TypeScript compiles without errors. Import { useAuth, AuthProvider } from '@/lib/context/authContext' works.</verify>
  <done>AuthContext exports AuthProvider and useAuth. signUp creates unverified user, signIn retrieves user, signOut clears state.</done>
</task>

<task type="auto">
  <name>Task 2: Add AuthProvider to app layout</name>
  <files>src/app/layout.tsx</files>
  <action>
Import AuthProvider from '@/lib/context/authContext'.
Wrap children with AuthProvider inside LocationProvider (auth depends on location for default city).

Order: LocationProvider > AuthProvider > children
  </action>
  <verify>npm run build passes. App loads without errors.</verify>
  <done>AuthProvider wraps app, useAuth accessible from any client component.</done>
</task>

<task type="auto">
  <name>Task 3: Create SignUpForm component</name>
  <files>src/components/features/signUpForm.tsx</files>
  <action>
Create 'use client' component for sign-up form:

1. Props interface:
   - onSuccess?: () => void
   - onSwitchToSignIn?: () => void

2. Form state with useState:
   - email, password, confirmPassword, firstName, lastName
   - errors object for field validation
   - isSubmitting boolean

3. Validation on submit:
   - Email: required, valid format (use simple regex)
   - Password: required, min 8 characters
   - Confirm password: must match password
   - First name: optional but recommended

4. On valid submit:
   - Call useAuth().signUp(email, password, firstName, lastName)
   - Handle errors (email already exists = show error)
   - On success: call onSuccess()

5. UI structure using existing components:
   - Input components for each field with error prop
   - Button with isLoading state
   - "Already have an account? Sign in" link calling onSwitchToSignIn

6. Styling: Stack form fields vertically, use space-y-4, glassmorphic inputs.
  </action>
  <verify>npm run build passes. Component renders without errors.</verify>
  <done>SignUpForm validates input, calls signUp on submit, shows errors, has switch to sign-in link.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes
- [ ] AuthContext properly typed with Consumer and VerificationStatus
- [ ] SignUpForm validates all fields
- [ ] No TypeScript errors
</verification>

<success_criteria>
- AuthProvider and useAuth exported and working
- AuthProvider added to app layout
- SignUpForm component with validation
- Mock sign-up creates user with 'unverified' status
- Ready for 04-02 (sign-in form and modal wrapper)
</success_criteria>

<output>
After completion, create `.planning/phases/04-consumer-auth/04-01-SUMMARY.md`
</output>
